const express = require("express")
const cors = require("cors")
const nodemailer = require("nodemailer")
const jwt = require("jsonwebtoken")
const { Server } = require("socket.io")
const http = require("http")
const multer = require("multer")
const path = require("path")
const fs = require("fs")
require("dotenv").config()

const app = express()
const server = http.createServer(app)
const io = new Server(server, {
  cors: {
    origin: "*",
    methods: ["GET", "POST"],
  },
  maxHttpBufferSize: 1e8, // 100 MB
})

app.use(cors())
app.use(express.json())
app.use("/uploads", express.static(path.join(__dirname, "uploads")))

// In-memory storage for development (replaces MongoDB)
const users = new Map() // email -> user object
const messages = new Map() // messageId -> message object
const statuses = new Map() // statusId -> status object
const calls = new Map() // callId -> call object
const groupChats = new Map() // groupId -> group object
let messageIdCounter = 1
let statusIdCounter = 1
let callIdCounter = 1
let groupIdCounter = 1
let userIdCounter = 1

// C·∫•u h√¨nh Nodemailer
let transporter
try {
  transporter = nodemailer.createTransport({
    host: process.env.SMTP_HOST || "smtp.gmail.com",
    port: Number.parseInt(process.env.SMTP_PORT || "587"),
    secure: process.env.SMTP_PORT === "465",
    auth: {
      user: process.env.EMAIL_USER,
      pass: process.env.EMAIL_PASS,
    },
  })
  console.log("‚úÖ Nodemailer transporter initialized successfully")
  console.log("üìß Email User:", process.env.EMAIL_USER)
} catch (error) {
  console.error("‚ùå Nodemailer initialization failed:", error)
}

console.log("‚úÖ Development server using in-memory storage (no MongoDB required)")

// L∆∞u OTP t·∫°m th·ªùi
const otpStorage = new Map()
// L∆∞u tr·ªØ ng∆∞·ªùi d√πng ƒëang ho·∫°t ƒë·ªông (email -> socket.id, userId)
const activeUsers = new Map() // email -> { socketId: string, userId: string }

// T·∫°o th∆∞ m·ª•c uploads n·∫øu ch∆∞a c√≥
const uploadsDir = path.join(__dirname, "uploads")
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir)
}

// C·∫•u h√¨nh Multer cho upload file
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadsDir)
  },
  filename: (req, file, cb) => {
    cb(null, `${Date.now()}-${file.originalname}`)
  },
})
const upload = multer({ storage: storage })

// T·∫°o OTP 6 s·ªë
function generateOTP() {
  return Math.floor(100000 + Math.random() * 900000).toString()
}

// Generate JWT Token
function generateToken(email, userId) {
  return jwt.sign({ email, userId }, process.env.JWT_SECRET || "dev-secret", { expiresIn: "30d" })
}

// Middleware ƒë·ªÉ x√°c th·ª±c JWT
async function verifyToken(req, res, next) {
  const token = req.headers.authorization?.split(" ")[1]
  if (!token) {
    return res.status(401).json({ success: false, message: "Token kh√¥ng ƒë∆∞·ª£c cung c·∫•p" })
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || "dev-secret")
    req.user = decoded // decoded s·∫Ω ch·ª©a email v√† userId
    // L·∫•y th√¥ng tin user t·ª´ in-memory storage
    const user = users.get(decoded.email)
    if (!user) {
      return res.status(401).json({ success: false, message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i" })
    }
    req.user.dbUser = user // L∆∞u ƒë·ªëi t∆∞·ª£ng user v√†o req
    next()
  } catch (error) {
    return res.status(401).json({ success: false, message: "Token kh√¥ng h·ª£p l·ªá" })
  }
}

// API g·ª≠i OTP qua Email
app.post("/api/send-otp", async (req, res) => {
  try {
    const { email } = req.body

    if (!email) {
      return res.status(400).json({
        success: false,
        message: "Email l√† b·∫Øt bu·ªôc",
      })
    }

    if (!email.includes("@") || !email.includes(".")) {
      return res.status(400).json({
        success: false,
        message: "ƒê·ªãa ch·ªâ email kh√¥ng h·ª£p l·ªá",
      })
    }

    const otp = generateOTP()

    otpStorage.set(email, {
      otp: otp,
      expiresAt: Date.now() + 5 * 60 * 1000,
      attempts: 0,
    })

    console.log(`üîê Generated OTP: ${otp} for ${email}`)

    if (!transporter) {
      console.log("üìß Using test OTP mode (no email sent)")
      return res.json({ 
        success: true, 
        message: "Test OTP generated (email service not configured)", 
        testOtp: otp 
      })
    }

    try {
      await transporter.sendMail({
        from: process.env.EMAIL_USER,
        to: email,
        subject: "M√£ x√°c th·ª±c WhatsApp NDT c·ªßa b·∫°n",
        html: `
          <div style="font-family: Arial, sans-serif; line-height: 1.6;">
            <h2>M√£ x√°c th·ª±c WhatsApp NDT c·ªßa b·∫°n</h2>
            <p>M√£ OTP c·ªßa b·∫°n l√†: <strong>${otp}</strong></p>
            <p>M√£ n√†y c√≥ hi·ªáu l·ª±c trong 5 ph√∫t.</p>
            <p>N·∫øu b·∫°n kh√¥ng y√™u c·∫ßu m√£ n√†y, vui l√≤ng b·ªè qua email n√†y.</p>
            <p>Tr√¢n tr·ªçng,</p>
            <p>ƒê·ªôi ng≈© WhatsApp NDT</p>
          </div>
        `,
      })

      console.log(`‚úÖ OTP email sent successfully to: ${email}`)
      res.json({ success: true, message: "OTP ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email c·ªßa b·∫°n!" })
    } catch (emailError) {
      console.error("‚ùå Email sending error:", emailError)
      res.json({ 
        success: true, 
        message: "Test OTP generated (email failed to send)", 
        testOtp: otp 
      })
    }
  } catch (error) {
    console.error("‚ùå General Error:", error)
    res.status(500).json({
      success: false,
      message: "L·ªói server: " + error.message,
    })
  }
})

// API x√°c th·ª±c OTP
app.post("/api/verify-otp", async (req, res) => {
  try {
    const { email, otp } = req.body

    if (!email || !otp) {
      return res.status(400).json({
        success: false,
        message: "Thi·∫øu th√¥ng tin c·∫ßn thi·∫øt",
      })
    }

    const stored = otpStorage.get(email)

    if (!stored) {
      return res.status(400).json({ success: false, message: "OTP kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ h·∫øt h·∫°n" })
    }

    if (Date.now() > stored.expiresAt) {
      otpStorage.delete(email)
      return res.status(400).json({ success: false, message: "OTP ƒë√£ h·∫øt h·∫°n" })
    }

    if (stored.otp !== otp) {
      stored.attempts++
      if (stored.attempts >= 3) {
        otpStorage.delete(email)
        return res.status(400).json({ success: false, message: "Qu√° s·ªë l·∫ßn th·ª≠" })
      }
      return res.status(400).json({ success: false, message: "OTP kh√¥ng ch√≠nh x√°c" })
    }

    otpStorage.delete(email)

    let user = users.get(email)

    if (!user) {
      user = {
        _id: `user_${userIdCounter++}`,
        email: email,
        verified: true,
        createdAt: new Date(),
        lastLogin: new Date(),
        name: "",
        status: "Hey there! I am using WhatsApp NDT.",
        profilePictureUrl: ""
      }
      users.set(email, user)
      console.log(`‚úÖ New user registered: ${email}`)
    } else {
      user.lastLogin = new Date()
      user.verified = true
      console.log(`‚úÖ User logged in: ${email}`)
    }

    const token = generateToken(user.email, user._id)

    res.json({
      success: true,
      message: "X√°c th·ª±c th√†nh c√¥ng!",
      token: token,
      user: {
        _id: user._id,
        email: user.email,
        name: user.name,
        status: user.status,
        profilePictureUrl: user.profilePictureUrl,
        createdAt: user.createdAt,
        lastLogin: user.lastLogin,
      },
    })
  } catch (error) {
    console.error("‚ùå Verify OTP Error:", error)
    res.status(500).json({ success: false, message: "L·ªói x√°c th·ª±c: " + error.message })
  }
})

// Test OTP (kh√¥ng g·ª≠i email th·∫≠t)
app.post("/api/test-otp", (req, res) => {
  try {
    const { email } = req.body

    if (!email) {
      return res.status(400).json({
        success: false,
        message: "Email l√† b·∫Øt bu·ªôc",
      })
    }

    const testOtp = "123456"

    otpStorage.set(email, {
      otp: testOtp,
      expiresAt: Date.now() + 5 * 60 * 1000,
      attempts: 0,
    })

    console.log(`üß™ Test OTP: ${testOtp} for ${email}`)
    res.json({ success: true, message: "Test OTP t·∫°o th√†nh c√¥ng", testOtp, email })
  } catch (error) {
    res.status(500).json({ success: false, message: "L·ªói t·∫°o test OTP" })
  }
})

// API l·∫•y th√¥ng tin profile (c·∫ßn token)
app.get("/api/profile", verifyToken, async (req, res) => {
  try {
    const user = req.user.dbUser
    res.json({
      success: true,
      user: {
        _id: user._id,
        email: user.email,
        name: user.name,
        status: user.status,
        profilePictureUrl: user.profilePictureUrl,
        createdAt: user.createdAt,
        lastLogin: user.lastLogin,
      },
    })
  } catch (error) {
    console.error("‚ùå Get Profile Error:", error)
    res.status(500).json({ success: false, message: "L·ªói khi l·∫•y th√¥ng tin h·ªì s∆°" })
  }
})

// API c·∫≠p nh·∫≠t profile (c·∫ßn token)
app.post("/api/profile/update", verifyToken, async (req, res) => {
  try {
    const { name, status, profilePictureUrl } = req.body
    const user = req.user.dbUser

    if (name !== undefined) user.name = name
    if (status !== undefined) user.status = status
    if (profilePictureUrl !== undefined) user.profilePictureUrl = profilePictureUrl

    users.set(user.email, user)

    res.json({
      success: true,
      message: "C·∫≠p nh·∫≠t h·ªì s∆° th√†nh c√¥ng",
      user: {
        _id: user._id,
        email: user.email,
        name: user.name,
        status: user.status,
        profilePictureUrl: user.profilePictureUrl,
        createdAt: user.createdAt,
        lastLogin: user.lastLogin,
      },
    })
  } catch (error) {
    console.error("‚ùå Update Profile Error:", error)
    res.status(500).json({ success: false, message: "L·ªói khi c·∫≠p nh·∫≠t h·ªì s∆°" })
  }
})

// API l·∫•y danh s√°ch t·∫•t c·∫£ ng∆∞·ªùi d√πng
app.get("/api/users", verifyToken, async (req, res) => {
  try {
    const currentUserId = req.user.userId
    const allUsers = Array.from(users.values()).filter(u => u._id !== currentUserId)

    res.json({
      success: true,
      users: allUsers.map(u => ({
        _id: u._id,
        email: u.email,
        name: u.name,
        status: u.status,
        profilePictureUrl: u.profilePictureUrl
      })),
      currentPage: 1,
      totalPages: 1,
      totalUsers: allUsers.length,
    })
  } catch (error) {
    console.error("‚ùå Get Users Error:", error)
    res.status(500).json({ success: false, message: "L·ªói khi l·∫•y danh s√°ch ng∆∞·ªùi d√πng" })
  }
})

// API upload file
app.post("/api/upload/file", verifyToken, upload.single("file"), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ success: false, message: "Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c t·∫£i l√™n." })
    }

    const fileUrl = `${req.protocol}://${req.get("host")}/uploads/${req.file.filename}`
    console.log(`‚úÖ File uploaded: ${fileUrl}`)
    res.json({ success: true, message: "File ƒë√£ ƒë∆∞·ª£c t·∫£i l√™n th√†nh c√¥ng", url: fileUrl })
  } catch (error) {
    console.error("‚ùå File Upload Error:", error)
    res.status(500).json({ success: false, message: "L·ªói khi t·∫£i file l√™n: " + error.message })
  }
})

// Basic messaging endpoints (simplified for development)
app.get("/api/messages/:chatId", verifyToken, async (req, res) => {
  const chatMessages = Array.from(messages.values()).filter(m => 
    (m.receiver === req.params.chatId && m.sender === req.user.userId) ||
    (m.sender === req.params.chatId && m.receiver === req.user.userId) ||
    m.group === req.params.chatId
  ).sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt))

  res.json({
    success: true,
    messages: chatMessages,
    currentPage: 1,
    totalPages: 1,
    totalMessages: chatMessages.length,
  })
})

// Health check
app.get("/api/health", (req, res) => {
  res.json({
    status: "OK",
    message: "Development server running!",
    timestamp: new Date().toISOString(),
    emailService: {
      initialized: !!transporter,
      user: process.env.EMAIL_USER,
    },
    database: {
      connected: true,
      type: "in-memory-dev",
    },
    activeOTPs: otpStorage.size,
    activeSocketUsers: activeUsers.size,
    totalUsers: users.size,
  })
})

// Socket.IO for real-time chat (simplified)
io.on("connection", (socket) => {
  console.log("üîå User connected:", socket.id)

  socket.on("signin", (userEmail) => {
    const user = users.get(userEmail)
    if (user) {
      socket.userEmail = userEmail
      socket.userId = user._id
      activeUsers.set(userEmail, { socketId: socket.id, userId: socket.userId })
      console.log(`üë§ User ${userEmail} (ID: ${socket.userId}) signed in with socket ID: ${socket.id}`)
      io.emit("user_status_update", { email: userEmail, isOnline: true })
    }
  })

  socket.on("message", (data) => {
    const { message, sourceEmail, targetEmail, type = "text", contentUrl } = data
    console.log(`üí¨ Message from ${sourceEmail} to ${targetEmail} (Type: ${type}): ${message}`)

    const newMessage = {
      _id: `msg_${messageIdCounter++}`,
      sender: socket.userId,
      receiver: targetEmail ? Array.from(users.values()).find(u => u.email === targetEmail)?._id : null,
      content: message,
      type: type,
      contentUrl: contentUrl,
      status: "sent",
      createdAt: new Date(),
    }
    
    messages.set(newMessage._id, newMessage)

    const targetSocketInfo = activeUsers.get(targetEmail)
    if (targetSocketInfo && targetSocketInfo.socketId) {
      io.to(targetSocketInfo.socketId).emit("message", {
        ...newMessage,
        sourceEmail,
        targetEmail,
        timestamp: newMessage.createdAt.toISOString(),
      })
      newMessage.status = "delivered"
    }

    // Send back to sender
    io.to(socket.id).emit("message", {
      ...newMessage,
      sourceEmail,
      targetEmail,
      timestamp: newMessage.createdAt.toISOString(),
      isSent: true
    })
  })

  socket.on("disconnect", () => {
    if (socket.userEmail) {
      activeUsers.delete(socket.userEmail)
      console.log(`üëã User ${socket.userEmail} disconnected`)
      io.emit("user_status_update", { email: socket.userEmail, isOnline: false })
    }
  })
})

const PORT = process.env.PORT || 3000
server.listen(PORT, () => {
  console.log(`üöÄ WhatsApp NDT Development Server running at: http://localhost:${PORT}`)
  console.log(`üì± Health check: http://localhost:${PORT}/api/health`)
  console.log(`üìÇ Uploads directory: ${uploadsDir}`)
  console.log(`üí¨ Socket.IO ready for real-time chat`)
  console.log(`üìä Database: In-memory storage (development mode)`)
  console.log(``)
})
